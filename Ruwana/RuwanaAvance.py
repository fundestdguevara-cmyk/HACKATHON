# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M093-Evj1gdStU0i_vwN_aBLzDy_qCwj
"""

import pandas as pd
import matplotlib.pyplot as plt
import os
import google.generativeai as genai
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import numpy as np
from dotenv import load_dotenv

# ================= CONFIGURACI√ìN SEGURA =================

genai.configure(api_key="AIzaSyB006uBHrMxxdJxMXfKvMs-6I6gj4Mz5Qk")
gemini_model = genai.GenerativeModel("gemini-2.5-flash")  # modelo real y disponible

COSTO_KWH = 0.13

# ================= FUNCIONES =================

def cargar_dataset_energy_star():
    """Carga datasets ENERGY STAR y extrae consumo promedio por tipo."""
    datasets_config = {
        "TV": {
            "archivo": "/content/ENERGY_STAR_Certified_Televisions_20251217.csv",
            "col_consumo": "Reported Annual Energy Consumption (kWh)"
        },
        "Computadora": {
            "archivo": "/content/ENERGY_STAR_Certified_Computers_V9.0_20251217.csv",
            "col_consumo": "Typical Energy Consumption (kWh)"
        },
        "Luminaria": {
            "archivo": "/content/ENERGY_STAR_Certified_Light_Fixtures_-_Downlights_20251217.csv",
            "col_consumo": "Total Input Power (Watts)"
        },
        "Ventilador": {
            "archivo": "/content/ENERGY_STAR_Certified_Ventilating_Fans_20251217.csv",
            "col_aire": "Airflow 1 (cfm)",
            "col_eficacia": "Efficacy 1 (cfm/Watt)"
        },
        "Lavadora_comercial": {
            "archivo": "/content/ENERGY_STAR_Certified_Commercial_Clothes_Washers_20251217.csv",
            "col_consumo": "Annual Energy Use (kWh/yr)"
        },
        "Aire_acondicionado": {
            "archivo": "/content/ENERGY_STAR_Certified_Room_Air_Conditioners_20251217.csv",
            "col_consumo": "Annual Energy Use (kWh/yr)"
        },
        "Refrigerador_comercial": {
            "archivo": "/content/ENERGY_STAR_Certified_Commercial_Refrigerators_and_Freezers_20251217.csv",
            "col_consumo": "Reported Daily Energy Consumption (kWh/day)"
        },
        "Cocina_electrica": {
            "archivo": "/content/ENERGY_STAR_Certified_Commercial_Electric_Cooktops_20251217.csv",
            "col_consumo": "Nameplate Input Rate (kW)"
        }
    }

    electrodomesticos_disponibles = []
    consumos_promedio = {}
    datasets_completos = {}  # Para guardar los DataFrames reales

    for nombre, config in datasets_config.items():
        archivo = config["archivo"]
        if not os.path.exists(archivo):
            continue

        try:
            df = pd.read_csv(archivo, low_memory=False)
        except Exception:
            continue

        # --- Procesamiento por tipo ---
        if nombre == "Luminaria":
            col = "Total Input Power (Watts)"
            if col not in df.columns: continue
            df[col] = pd.to_numeric(df[col].astype(str).str.replace(",", ""), errors='coerce')
            df = df.dropna(subset=[col])
            df["consumo_kwh_anual"] = (df[col] * 1095) / 1000
        elif nombre == "Ventilador":
            col_aire = "Airflow 1 (cfm)"; col_efic = "Efficacy 1 (cfm/Watt)"
            if col_aire not in df.columns or col_efic not in df.columns: continue
            df[col_aire] = pd.to_numeric(df[col_aire].astype(str).str.replace(",", ""), errors='coerce')
            df[col_efic] = pd.to_numeric(df[col_efic].astype(str).str.replace(",", ""), errors='coerce')
            df = df.dropna(subset=[col_aire, col_efic])
            df["consumo_kwh_anual"] = (df[col_aire] / df[col_efic] * 1095) / 1000
        elif nombre == "Refrigerador_comercial":
            col = "Reported Daily Energy Consumption (kWh/day)"
            if col not in df.columns: continue
            df[col] = pd.to_numeric(df[col], errors='coerce')
            df = df.dropna(subset=[col])
            df["consumo_kwh_anual"] = df[col] * 365
        elif nombre == "Cocina_electrica":
            col = "Nameplate Input Rate (kW)"
            if col not in df.columns: continue
            df[col] = pd.to_numeric(df[col], errors='coerce')
            df = df.dropna(subset=[col])
            df["consumo_kwh_anual"] = df[col] * 1 * 365  # 1 h/d√≠a
        else:
            col = config["col_consumo"]
            if col not in df.columns: continue
            df[col] = pd.to_numeric(df[col], errors='coerce')
            df = df.dropna(subset=[col])
            df["consumo_kwh_anual"] = df[col]

        if df.empty or "consumo_kwh_anual" not in df.columns:
            continue

        promedio = df["consumo_kwh_anual"].mean()
        consumos_promedio[nombre] = promedio / 12  # mensual
        electrodomesticos_disponibles.append(nombre)
        datasets_completos[nombre] = df  # Guardamos el dataset real

    return electrodomesticos_disponibles, consumos_promedio, datasets_completos

def cargar_dataset():
    """Genera dataset sint√©tico para KMeans de usuarios (como en tu c√≥digo original)."""
    electrodomesticos, consumos_promedio, _ = cargar_dataset_energy_star()
    global ELECTRODOMESTICOS
    ELECTRODOMESTICOS = electrodomesticos

    np.random.seed(42)
    n_filas = 100
    data_sim = {}
    for ap in electrodomesticos:
        base = consumos_promedio[ap]
        data_sim[ap] = np.random.normal(loc=base, scale=base * 0.15, size=n_filas)
        data_sim[ap] = np.clip(data_sim[ap], a_min=0.1, a_max=None)

    return pd.DataFrame(data_sim)

def inicializar_kmeans(df):
    X = df[ELECTRODOMESTICOS]
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
    df["Cluster"] = kmeans.fit_predict(X_scaled)
    return kmeans, scaler, df

def recomendar_modelos_reales(aparato, consumo_usuario_kwh_anual, datasets_completos, n_top=3):
    """Recomienda los n_top modelos m√°s eficientes del dataset real."""
    if aparato not in datasets_completos:
        return []

    df = datasets_completos[aparato].copy()
    df = df.sort_values("consumo_kwh_anual").head(n_top)

    recomendaciones = []
    for _, row in df.iterrows():
        marca = row.get("Brand Name", "N/A")
        modelo = row.get("Model Name", "N/A")
        consumo = row["consumo_kwh_anual"]
        ahorro_kwh = max(0, consumo_usuario_kwh_anual - consumo)
        ahorro_usd = ahorro_kwh * COSTO_KWH
        recomendaciones.append({
            "marca": marca,
            "modelo": modelo,
            "consumo_kwh_anual": consumo,
            "ahorro_kwh": ahorro_kwh,
            "ahorro_usd": ahorro_usd
        })
    return recomendaciones

def mensaje_gemini(texto):
    try:
        return gemini_model.generate_content(texto, safety_settings={
            'HARM_CATEGORY_HARASSMENT': 'BLOCK_NONE',
            'HARM_CATEGORY_HATE_SPEECH': 'BLOCK_NONE',
            'HARM_CATEGORY_SEXUALLY_EXPLICIT': 'BLOCK_NONE',
            'HARM_CATEGORY_DANGEROUS_CONTENT': 'BLOCK_NONE'
        }).text
    except Exception as e:
        return f"‚ö†Ô∏è Error con Gemini: {e}"

def visualizar_consumo(consumo_usuario, promedio_cluster, cluster):
    df_comparacion = pd.DataFrame({
        'Usuario': consumo_usuario,
        f'Promedio Cluster {cluster}': promedio_cluster
    })

    plt.style.use('seaborn-v0_8-whitegrid')
    fig, ax = plt.subplots(figsize=(10, 6))
    bar_width = 0.35
    x_pos = np.arange(len(ELECTRODOMESTICOS))

    bar1 = ax.bar(x_pos - bar_width/2, df_comparacion['Usuario'], bar_width, label='Mi Consumo (kWh)', color='#4CAF50')
    bar2 = ax.bar(x_pos + bar_width/2, df_comparacion[f'Promedio Cluster {cluster}'], bar_width, label=f'Promedio Cluster {cluster} (kWh)', color='#2196F3')

    ax.set_ylabel('Consumo Mensual (kWh)', fontsize=12)
    ax.set_title(f'üìä Comparaci√≥n: Usuario vs. Cluster {cluster}', fontsize=14, fontweight='bold')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(ELECTRODOMESTICOS, rotation=0, fontsize=11)
    ax.legend()

    def autolabel(rects):
        for rect in rects:
            height = rect.get_height()
            ax.annotate(f'{height:.1f}',
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom', fontsize=9)
    autolabel(bar1)
    autolabel(bar2)
    plt.tight_layout()
    plt.show()

def chatbot():
    print("‚ú®" * 30)
    print("ü§ñ Asistente Energ√©tico Inteligente (ENERGY STAR)")
    print("‚ú®" * 30)

    # Cargar datos reales y datasets completos
    electrodomesticos, consumos_promedio, datasets_completos = cargar_dataset_energy_star()
    if not electrodomesticos:
        print("‚ùå No se encontraron datasets v√°lidos.")
        return

    global ELECTRODOMESTICOS
    ELECTRODOMESTICOS = electrodomesticos

    # Generar dataset sint√©tico para KMeans de usuarios
    df = pd.DataFrame({
        ap: np.random.normal(loc=consumos_promedio[ap], scale=consumos_promedio[ap]*0.15, size=100)
        for ap in electrodomesticos
    })
    kmeans, scaler, df = inicializar_kmeans(df)

    # Entrada del usuario
    consumo_usuario = {}
    for ap in ELECTRODOMESTICOS:
        while True:
            try:
                val = float(input(f"üëâ Consumo mensual de **{ap}** (kWh): "))
                consumo_usuario[ap] = val
                break
            except ValueError:
                print("üö® Ingresa un n√∫mero v√°lido.")

    consumo_usuario = pd.Series(consumo_usuario)
    usuario_scaled = scaler.transform([consumo_usuario])
    cluster = kmeans.predict(usuario_scaled)[0]
    promedio_cluster = df[df["Cluster"] == cluster][ELECTRODOMESTICOS].mean()

    visualizar_consumo(consumo_usuario, promedio_cluster, cluster)

    # An√°lisis general
    prompt_general = f"""
    El usuario pertenece al cluster {cluster}. Su consumo:
    {consumo_usuario.to_string()}
    Promedio del cluster:
    {promedio_cluster.to_string()}
    Explica si su consumo es alto o bajo, qu√© significa este cluster, y da 3 consejos generales.
    """
    print("--- üí¨ An√°lisis del Asistente ---")
    print(mensaje_gemini(prompt_general))
    print("--------------------------------\n")

    # Recomendaciones con modelos reales
    print("--- üí° Recomendaciones con Modelos ENERGY STAR Reales ---")
    hubo_recomendaciones = False

    for ap in ELECTRODOMESTICOS:
        consumo_usuario_kwh_anual = consumo_usuario[ap] * 12
        consumo_promedio_kwh_anual = promedio_cluster[ap] * 12

        if consumo_usuario_kwh_anual > consumo_promedio_kwh_anual * 1.1:
            hubo_recomendaciones = True
            modelos = recomendar_modelos_reales(ap, consumo_usuario_kwh_anual, datasets_completos, n_top=2)
            if modelos:
                info_modelos = "\n".join([
                    f"- {m['marca']} {m['modelo']}: {m['consumo_kwh_anual']:.1f} kWh/a√±o (ahorro: ${m['ahorro_usd']:.2f}/a√±o)"
                    for m in modelos
                ])
                prompt = f"""
                El usuario consume alto en **{ap}** ({consumo_usuario_kwh_anual:.1f} kWh/a√±o vs promedio {consumo_promedio_kwh_anual:.1f}).
                Recomienda estos modelos ENERGY STAR:
                {info_modelos}
                Explica por qu√© son ideales y el ahorro total esperado.
                """
                print(f"\n‚ö°Ô∏è ¬°ALERTA DE ALTO CONSUMO en {ap.upper()}!")
                print(mensaje_gemini(prompt))
                print("---")
            else:
                print(f"\n‚ö°Ô∏è ¬°ALERTA! Alto consumo en {ap.upper()}, pero no hay modelos reales disponibles para recomendar.")

    if not hubo_recomendaciones:
        print("üéâ ¬°Felicidades! Tu consumo est√° en l√≠nea con tu cluster.")

    print("\n‚úÖ An√°lisis completado.")
    print("‚ú®" * 30)

if __name__ == "__main__":
    chatbot()